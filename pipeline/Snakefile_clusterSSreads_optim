import os
import subprocess
import zipfile

configfile: "config_HG00514.yaml"
#SHORTREADS = config["shortreads"]
#ALIGNERBINPATH = config["graphalignerfolder"]
GRAPHPATH = config["graphfolder"]
SCRIPTPATH = config["graphalignerfolder"] + "scripts"
#BCALMPATH = config["bcalmpath"]
#CONVERTTOGFAPATH = config["bcalm_converttoGFApath"]
#BGREAT = config["bgreat"]
#EXTRACTFASTQ = config["extract_fastq"]
#inputDir = config["input_dir"]
#softClustDir = config["soft_clust_dir"]
#outputDir = "output"#config["output_dir"]
SSfastqDir = config["SS_fastq_dir"]
SSbamDir = config["SS_bam_dir"]
#VG = config["VG"]
#nodelens = config["node_lens"]
chroms = ["chr" + str(x) for x in range(1, 23)]# + ["chrX"]
#exportFasta = config["export_fasta_path"]
#computeSimpleBubble = config["simple_bubble_detection_path"]
#getSNVbubbles = config["get_snv_bubbles_path"]
#getRevcompFree = config["get_rev_comp_free_path"]
#clustersizes = config["cluster_sizes"]
phasedSSvcfDir = config["phased_vcf_dir"]
whatshap = config["whatshap"]
PBbamDir = config["pb_bam_dir"]
minPBlen = config["min_pb_len"]
#platinumVCFdir = config["platinum_vcf_dir"]
N = config["Nchunks"]
l = len(str(N))
chunkID = ['0'*(l-len(str(i)))+str(i) for i in range(N)]
#chunkID = ['000']
sample = config["sample"]
w = config["w"]
#w="-default"
kMinimap = config["k_minimap"]
fMinimap = config["f"]
z = config["z"]
outputfolder    = "SaaRclust_results"
numClustersHard = config["numClustersHard"]
numClustersSoft = config["numClustersSoft"]
EMiter          = config["EMiter"]
alpha           = config["alpha"]
minLib          = config["minLib"]
upperQ          = config["upperQ"]
logLth          = config["logLth"]
theta_constrain = config["theta_constrain"]
log_scale  	= config["log_scale"]
numAlignments   = config["numAlignments"]


minimapHeader = "SSreadNames\\tSSreadLen\\tQueryCoordStart\\tQueryCoordend\\tstrand\\tPBreadNames\\tPBreadLen\\tTargetCoordStart\\tTargetCoordend\\tNumResidueMatches\\tMatchedBasesWithGaps\\tcigar"
minimapExtendedHeader = "SSreadNames\\tSSlibNames\\tSSflag\\tSSchrom\\tSSpos\\tSSreadLen\\tQueryCoordStart\\tQueryCoordend\\tstrand\\tPBreadNames\\tPBflag\\tPBchrom\\tPBpos\\tPBreadLen\\tTargetCoordStart\\tTargetCoordend\\tNumResidueMatches\\tMatchedBasesWithGaps\\tcigar"

print(minimapExtendedHeader)

libs, = glob_wildcards(SSfastqDir+"/{lib}_1.fastq.gz")
PBbamfiles,=glob_wildcards(PBbamDir+"/{bamfile}.bam")
print(libs)
print(SSfastqDir)


###############################################
#######		python functions	#######
###############################################

#def getclustersize(cl, filename):
#	return subprocess.getoutput("awk \'$3==\"" + cl + "\" {print $2}\' " + filename)
#
#print("getclustersize(V23) = ", getclustersize('V23', clustersizes))
		

###############################################

clusters = ["V"+str(i) for i in range(1, 48)]
directions = ["watson", "crick"]
haplotypes = [1,2]
haplotype_tags = ["HP:i:1", "HP:i:2"]


wildcard_constraints:
	graphname = "k\d+_a\d+_u\d+",
	k = "\d+",
	a = "\d+",
	u = "\d+",
	l = "\d+",
	longnodesize = "\d+",
	overlapsize = "\d+",
	longreads = "[^_]+",
	shortreads = "[^_]+",
	clust = "[V]\d+",
	chunks = "[0-9]+",
	sample=sample,


rule all:
	input:
		#expand("aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/SS_clusters.data", kMinimap=kMinimap, w=w, f=fMinimap, z=z, sample=sample),
		#expand("aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/statistics/histogram_ss_cov_in_long_reads.pdf", kMinimap=kMinimap, w=w, f=fMinimap, z=z, sample=sample),
		#expand("aligns_k{kMinimap}_w{w}_f{f}_z{z}/phased_long_reads/pb_phase_k{k}_a{a}_l{l}_{sample}.data", k=config["k"], a = config["kmer_abundance"], l = config["l"], kMinimap=kMinimap, w=w, f=fMinimap, z=z, sample=sample),
		#expand(SSfastqDir + "/bubble_SSlib_cov_cluster{clust}_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data", clust=clusters, k=config["k"], a = config["kmer_abundance"], l = config["l"], kMinimap=kMinimap, w=w, f=fMinimap, z=z, sample=sample),
		#expand("phased_strand_states/haplo_strand_states_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data", k=config["k"], a = config["kmer_abundance"], l = config["l"], kMinimap=kMinimap, w=w, f=fMinimap, z=z, sample=sample),
		#expand("aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/saarclust_accuracy_plot.pdf", kMinimap=kMinimap, w=w, f=fMinimap, z=z, sample=sample),
		#expand("bubbles/iteration1_phased_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}_withclsut.data", k=config["k"], a = config["kmer_abundance"], l = config["l"], kMinimap=kMinimap, w=w, f=fMinimap, z=z, sample=sample),
		#expand("aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_SS_cov.data", kMinimap=kMinimap, w=w, f=fMinimap, z=z, sample=sample, chunks=chunkID),
		#expand("aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/SS_clusters.data", kMinimap=kMinimap, w=w, f=fMinimap, z=z, sample=sample),
		expand("aligns_k{kMinimap}_w{w}_f{f}_z{z}/phased_long_reads/iteration2_pb_phase_chunk{chunks}_k{k}_a{a}_l{l}_{sample}.data", k=config["k"], a = config["kmer_abundance"], l = config["l"], kMinimap=kMinimap, w=w, f=fMinimap, z=z, sample=sample, chunks=chunkID)


###############################################################################
##############		merging read pairs with PEAR		###############
###############################################################################

rule pear_merge_mates:
	input:
		fq1=SSfastqDir+"/{lib}_1.fastq.gz",
		fq2=SSfastqDir+"/{lib}_2.fastq.gz",
        
	output:
		SSfastqDir+"/merged/{lib}.assembled.fastq",
		SSfastqDir+"/merged/{lib}.discarded.fastq",
		SSfastqDir+"/merged/{lib}.unassembled.forward.fastq",
		SSfastqDir+"/merged/{lib}.unassembled.reverse.fastq"
        
	log: "log/pear_merge_mates_{lib}.log"
        
	shell: "(time pear -f {input.fq1} -r {input.fq2} -t 101 -o {SSfastqDir}/merged/{wildcards.lib}) > {log} 2>&1"
	

rule concat_merged_with_first_unmerged:
	input:
		SSfastqDir+"/merged/{lib}.assembled.fastq",
		SSfastqDir+"/merged/{lib}.unassembled.forward.fastq",
	output: temp(SSfastqDir+"/merged/{lib}.combined.fastq")
	log: "log/concat_merged_with_first_unmerged_{lib}.log"
	shell: "(time cat {input} > {output}) > {log} 2>&1"

###############################################################################
##############	     Adding ground true info to SS read names	###############
###############################################################################

rule bwa_map_SS_to_ref:
	input:
		ref=config["reference"],
		amb=config["reference"] + ".amb",
		ann=config["reference"] + ".ann",
		bwt=config["reference"] + ".bwt",
		pac=config["reference"] + ".pac",
		sa= config["reference"] + ".sa",
		ss= SSfastqDir+"/merged/{lib}.combined.fastq"
	output: SSbamDir+"/{lib}.bam"
	threads: 8
	log: "log/bwa_map_SS_to_ref_{lib}.log"
	shell: "(time bwa mem -t {threads} {input.ref} {input.ss} | samtools view -Sb - > {output}) > {log} 2>&1"

rule sort_SS_bam:
	input: SSbamDir+"/{lib}.bam"
	output: SSbamDir+"/{lib}.sorted.bam"
	log: "log/sort_SS_bam_{lib}.log"
	shell: "(time samtools sort -o {output} {input}) > {log} 2>&1"

rule export_SS_fasta_from_bam:
	input: SSbamDir+"/{lib}.bam"
	output: SSfastqDir+"/merged/{lib}.combined.withmapinfo.fasta"
	log: "log/export_SS_fasta_from_bam_{lib}.log"
	shell:
		'''
		(time bioawk -c sam '{{s=$seq; if(and($flag, 16)) {{s=revcomp($seq)}} print \">\" $qname \"_{wildcards.lib}_\" $flag \"_\" $rname \"_\" $pos \"\\n\" s}}' \
		<(samtools view -F 4 {input}) > {output}) > {log} 2>&1
		'''


###############################################################################
##############	     Adding ground true info to SS read names	###############
###############################################################################

#TODO: remove the first two rules (they are going to be generated by Snakefile_prepare_input file)

rule export_pacbio_reads:
	input: PBbamDir+"/{bamfile}.bam"
	output: expand(PBbamDir+"/{sample}_{{bamfile}}.fasta", sample=sample)
	log: "log/export_pacbio_reads_{bamfile}.log"
	shell:
		'''
		(time bioawk -c sam '{{s=$seq; if(and($flag, 16)) {{s=revcomp($seq)}} if(length(s)>{minPBlen})print \">\" $qname \"_\" $flag \"_\" $rname \"_\" $pos \"\\n\" s}}' \
		<(samtools view -F 260 {input} | awk '!seen[$1]++') > {output}) > {log} 2>&1
		'''

rule concat_all_fasta:
	input: expand(PBbamDir+"/{{sample}}_{bamfile}.fasta", bamfile=PBbamfiles)
	output: temp(PBbamDir+"/{sample}.fasta")
	log: "log/concat_all_fasta_{sample}.log"
	shell: "(time cat {input} > {output}) > {log} 2>&1"

#rule split_fasta_file:
#	input: expand(PBbamDir+"/{sample}.fasta", sample=sample)
#	output: expand(PBbamDir+"/{sample}.{chunks}.fasta", chunks=chunkID, sample=sample)
#	log: "log/split_fasta_file.log"
#	shell: "(time pyfasta split -n {N} {input}) > {log} 2>&1"
	



###############################################################################
##############	     minimap aliging SS reads to PB reads	###############
###############################################################################


rule minimap2_align_SS_to_PB:
	input:
		pb_reads=PBbamDir+"/{sample}.{chunks}.fasta",
		ss_reads=expand(SSfastqDir+"/merged/{lib}.combined.withmapinfo.fasta", lib=libs)
	output: temp("aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_temp.paf.gz")
	threads: 8
	log: "log/minimap_align_chunks_{sample}_chunk{chunks}_{kMinimap}_w{w}_f{f}_z{z}.log"
	shell: "(time minimap2 -c -t{threads} -k{wildcards.kMinimap} -w{wildcards.w} -f{wildcards.f} -z{wildcards.z} {input.pb_reads} {input.ss_reads} | gzip -c > {output}) > {log} 2>&1"
	#shell: "(time minimap2 -c -t{threads} -k{wildcards.kMinimap} -f{wildcards.f} -z{wildcards.z} {input.pb_reads} {input.ss_reads} | gzip -c > {output}) > {log} 2>&1"


# remove SS read names with unknown chromosomes and output columns 1 through 11 and the last column (cigar) of the minimap output
rule process_minimap_output:
	input: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_temp.paf.gz"
	output: temp("aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}.paf.gz")
	log:"log/process_minimap_output_k{kMinimap}_w{w}_f{f}_z{z}_{sample}_chunk{chunks}.log"
	shell:
		'''
		(time cat <(echo -e \"{minimapHeader}\") <(zcat {input} | awk '$1~/chr([0-9]+|X)_[0-9]+$/{{print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$NF}}') | gzip -c > {output}) > {log} 2>&1
		'''


rule extend_minimap_columns_by_ground_truth_info:
	input:  "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}.paf.gz"
	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}.maf.gz"
	log: "log/extend_minimap_columns_by_ground_truth_info_k{kMinimap}_w{w}_f{f}_z{z}_{sample}_chunk{chunks}.log"
	shell:
		'''
		(time cat <(echo -e \"{minimapExtendedHeader}\") <(zcat {input} | tail -n +2 | gawk 'match($1, /(.*)_(.*)_(.*)_(.*)_(.*)/, ss) match($6, /(.*)_(.*)_(.*)_(.*)/, pb) \
		{{print ss[1] \"\t\" ss[2] \"\t\" ss[3] \"\t\" ss[4] \"\t\" ss[5] \
		\"\t\" $2 \"\t\" $3 \"\t\" $4 \"\t\" $5 \"\t\" \
		pb[1] \"\t\" pb[2] \"\t\" pb[3] \"\t\" pb[4] \"\t\" \
		$7 \"\t\" $8 \"\t\" $9 \"\t\" $10 \"\t\" $11 \"\t\" $12}}') | gzip -c > {output}) > {log} 2>&1
		'''


###############################################################################
##############	   	  minimap evaluation			###############
###############################################################################



rule intersect_pb_ss_bams:
	input:
		pb=PBbamDir+"/{sample}.{chunks}.sorted.bam",
		#ss=config["SS_bam_dir"]+"/{lib}_srt_dedup.bam"
		ss=SSbamDir+"/{lib}.sorted.bam"
	output: PBbamDir+"/intersect_with_ss_bams/intersect_{sample}.{lib}.{chunks}.bed"
	log: "log/intersect_pb_ss_bams_{sample}_{lib}_{chunks}.log"
	shell: "(time bedtools intersect -bed -a <(samtools view -F 2304 -Sb {input.pb}) -b {input.ss} -wa -wb > {output}) > {log} 2>&1"


rule evaluate_minimap:
	input: 
		minimap="aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}.maf.gz",
		#pb_ss_intersect=expand(PBbamDir+"/intersect_with_ss_bams/intersect_{{sample}}.{lib}.{{chunks}}.bed", lib=libs),
		log    ="log/minimap_align_chunks_{sample}_chunk{chunks}_{kMinimap}_w{w}_f{f}_z{z}.log"
	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_evaluation.txt"
	params:
		overlap=0.8
	script: "utils/evaluate_minimap.py"


rule concat_minimap_evaluation_results:
	input: 
		minimap_eval=expand("aligns_k{kMinimap}_w{w}_f{f}_z{z}/{{sample}}_chunk{{chunks}}_evaluation.txt", kMinimap=kMinimap, w=w, f=fMinimap, z=z),
		pb_ss_intersect=expand(PBbamDir+"/intersect_with_ss_bams/intersect_{{sample}}.{lib}.{{chunks}}.bed", lib=libs)
	output:"minimap_evaluation_{sample}_chunk{chunks}.txt"
	shell:
		'''
		declare -i l=0
		for g in {input.pb_ss_intersect}
		do
		l=$((l+$(awk \'{{print $4, $16}}\' $g | sort | uniq | wc -l)))
		done
		echo \"total number of overlaps = \" $l > {output}
		for f in {input.minimap_eval}
		do
			echo $f \"\n\" >> {output}
			cat $f >> {output}
			echo \"\n\" >> {output}
		done
		'''


#rule evaluate_minimap:
#	input: 
#		minimap="aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}.maf.gz",
#		log    ="log/minimap_align_chunks_{sample}_chunk{chunks}.log"
#	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_evaluation.txt"
#	params:
#		overlap=0.8
#	script: "utils/evaluate_minimap.py"

#######################################################################################################
##############	     SaaRclust: clustering PacBio reads	by chromosome and direction	###############
#######################################################################################################


rule output_ss_cov_in_long_reads:
	input: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}.maf.gz"
	output:
		ss_cov="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/statistics/ss_cov_in_long_reads_chunk{chunks}.data",
		ss_lib_cov = "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/statistics/ss_lib_cov_in_long_reads_chunk{chunks}.data"
	log: "log/output_ss_cov_in_long_reads_k{kMinimap}_w{w}_f{f}_z{z}_{sample}_chunk{chunks}.log"
	shell: 
		'''
		(time zcat {input} | tail -n +2 | awk '{{print $10}}' | sort | uniq -c > {output.ss_cov} &&
		time zcat {input} | tail -n +2 | awk '{{print $2, $10}}' | sort | uniq | awk '{{print $2}}' | sort | uniq -c > {output.ss_lib_cov}
		) > {log} 2>&1
		'''


rule plot_ss_cov_in_long_reads_hist:
	input:
		ss_cov=expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/"+outputfolder+"_{{sample}}/statistics/ss_cov_in_long_reads_chunk{chunks}.data", chunks=chunkID),
		ss_lib_cov = expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/"+outputfolder+"_{{sample}}/statistics/ss_lib_cov_in_long_reads_chunk{chunks}.data", chunks=chunkID)
	output:	"aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/statistics/histogram_ss_cov_in_long_reads.pdf"
	log: "log/plot_ss_cov_in_long_reads_k{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
	script: "utils/plot_ss_cov_histo_in_long_reads.snakemake.R"


rule install_SaaRclust:
	output:
		"utils/R-packages/SaaRclust/R/SaaRclust"
	log: "log/saarclust-install.log"
	shell:
		"""
		TAR=$(which tar) Rscript utils/install_SaaRclust.R > {log} 2>&1
		"""

rule HARD_clustering:
	input:
		minimapFiles = expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/{sample}_chunk{chunks}.maf.gz", sample=sample, chunks=chunkID), 
		saarclust="utils/R-packages/SaaRclust/R/SaaRclust"
	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/hardClusteringResults_{numClustersHard}clusters.RData"
	log: "log/HARD_clustering_{sample}_k{kMinimap}_w{w}_f{f}_z{z}_{numClustersHard}.log"
	shell:
		"""
		(time Rscript utils/SaaRclust_hardclust_pipeline.R \
		aligns_k{wildcards.kMinimap}_w{wildcards.w}_f{wildcards.f}_z{wildcards.z} \
		aligns_k{wildcards.kMinimap}_w{wildcards.w}_f{wildcards.f}_z{wildcards.z}/{outputfolder}_{sample} \
		{numClustersHard} \
		{alpha} \
		{numAlignments} \
		{log_scale} \
		$(pwd)/utils/R-packages/) \
		> {log} 2>&1
		"""

rule plot_num_found_clusters:
	input: expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/"+outputfolder+"_{{sample}}/Clusters/hardClusteringResults_{numClustersHard}clusters.RData", numClustersHard=numClustersHard)
	output:
		table="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/hardClusteringResults_num_hitted_clusters.data",
		plot="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/hardClusteringResults_num_hitted_clusters.pdf"
	log: "log/plot_num_found_clusters_k{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
	script: "utils/plot_num_found_clusters.snakemake.R"


rule SOFT_clustering:
	input:
		minimapFile = "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}.maf.gz",
		HCclustFile = expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/"+outputfolder+"_{{sample}}/Clusters/hardClusteringResults_{numClustersHard}clusters.RData", numClustersHard=numClustersHard),
		saarclust="utils/R-packages/SaaRclust/R/SaaRclust"
    
	output:
		"aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/{sample}_chunk{chunks}_clusters.RData"
	log:
		"log/SOFT_clustering_k{kMinimap}_w{w}_f{f}_z{z}_{sample}_chunk{chunks}.log"
	shell:
		"""
		(time Rscript utils/SaaRclust_softclust_pipeline.R \
		{input.minimapFile} \
		aligns_k{wildcards.kMinimap}_w{wildcards.w}_f{wildcards.f}_z{wildcards.z}/{outputfolder}_{sample} \
		{numClustersSoft} \
		{EMiter} \
		{alpha} \
		{minLib} \
		{upperQ} \
		{logLth} \
		{input.HCclustFile} \
		{log_scale} \
		$(pwd)/utils/R-packages/) \
		> {log} 2>&1
		"""


rule create_SaaRclust_evaluation_plots:
	input:
		saarclust="utils/R-packages/SaaRclust/R/SaaRclust",
		soft_clust=expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/"+outputfolder+"_{{sample}}/Clusters/{{sample}}_chunk{chunks}_clusters.RData", chunks=chunkID)
	output:
		acc_table="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/saarclust_accuracy.table",
		acc_plot= "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/saarclust_accuracy_plot.pdf"
	params:
		inputfolder="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}",
		minLib=5
	log: "log/create_SaaRclust_evaluation_plots_k{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
	script: "utils/SaaRclust_evaluation_plots.snakemake.R"


rule output_wc_cells_clusters:
	input:
		soft_clust=expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/"+outputfolder+"_{{sample}}/Clusters/{{sample}}_chunk{chunks}_clusters.RData", chunks=chunkID[0]),
		clust_patrners="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/clust_partners.txt"
	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/wc_cells_clusters.data"
	params:
		min_theta_wc=0.75
	log: "log/output_wc_cells_clusters_k{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
	script: "utils/export_wc_cells_clusters.snakemake.R"

###############################################################################
##############	   	  adding clust info to files		###############
###############################################################################

# Debug: the rule doesn't run parallely
# TODO: keep the order of the columns
#rule add_soft_clust_to_original_map_files:
#	input:
#		minimap_file = "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}.maf.gz",
#		soft_clust_file = "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/{sample}_chunk{chunks}_clusters.RData"
#	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_withclust.maf.gz"
#	log: "log/add_soft_clust_to_original_map_files_{sample}_chunk{chunks}_k{kMinimap}_w{w}_f{f}_z{z}.log"
#	script: "utils/addSoftProbs.R"

rule output_soft_clust_in_long_reads:
	input:
		soft_clust_file = "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/{sample}_chunk{chunks}_clusters.RData"
	output: temp("aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/soft_clusters_long_reads_chunk{chunks}.data")
	log: "log/output_soft_clust_in_long_reads_{sample}_k{kMinimap}_w{w}_f{f}_z{z}_chunk{chunks}.log"
	script: "utils/outputSoftProbs.R"

rule concat_long_reads_soft_clusters:
	input: temp(expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/"+outputfolder+"_{{sample}}/Clusters/soft_clusters_long_reads_chunk{chunks}.data", chunks=chunkID))
	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/soft_clusters_long_reads.data"
	log: "log/concat_long_reads_soft_clusters_k{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
	shell:
		'''
		(time echo PBreadNames\\\tML_cluster_idx\\\tmax_cluster_prob > {output} &&
		cat {input} >> {output}) > {log} 2>&1
		'''


### TODO (for the next two rules): you should later take into account the flags which are not equal to 0 nor 16!

#rule count_clust_chrom_dir:
#	input: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_withclust.maf.gz",
#	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_clust_chrom_dir_count.data"
#	log: "log/count_clust_chrom_dir_{sample}_chunk{chunks}_k{kMinimap}_w{w}_f{f}_z{z}.log"
#	shell:
#		'''
#		(time zcat {input} | tail -n +2 | awk '{{print $1, $12\"_\"$11, $20}}' | sort | uniq -c | awk '{{print $3, $4}}' | sort | uniq -c > {output}) > {log} 2>&1
#		'''


rule map_clust_to_chrom_dir:
	input:
		hard_clust=expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/"+outputfolder+"_{{sample}}/Clusters/hardClusteringResults_{numClustersHard}clusters.RData", numClustersHard=numClustersHard)
	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/clust_partners.txt"
	log: "log/map_clust_to_chrom_dir_{sample}_k{kMinimap}_w{w}_f{f}_z{z}.log"
	shell: 
		'''
		(time Rscript utils/map_clust_to_chrom_dir.snakemake.R \
		{input.hard_clust}  \
		{output} \
		$(pwd)/utils/R-packages/ ) > {log} 2>&1
		'''


#rule append_clusters_to_pb_read_names:
#	input:
#		minimap_file="aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_withclust.maf.gz",
#		pb=PBbamDir+"/{sample}.{chunks}.fasta"
#	output: PBbamDir+"/{sample}.{chunks}_withclust_k{kMinimap}_w{w}_f{f}_z{z}.fasta"
#	run:
#		# mapping PacBio readNames to their clusters and soft probs
#		pb_name_to_clust={}
#		with zipfile.ZipFile(input["minimap_file"]) as z:
#			with open(z) as clustpb:
#				for line in clustpb:
#					sp = line.strip().split()
#					if sp[0] != "PBreadNames":
#						pb_name_to_clust[sp[0]]=(sp[19], sp[20])
#		
#		# writing PacBio reads clusters in the PacBio fasta file
#		with open(input["pb"]) as f:
#			with open(output[0], 'w') as out:
#				for line in f:
#					if line[0]==">":
#						sp = line.split()[0].split("_")
#						if len(sp) > 3:
#							pb_name = "_".join(sp[:-3])[1:]		# remove the '>' char and the extra info (4 last elements in the '_' splitted list) added to the pb read name
#						if len(sp) > 3 and pb_name in pb_name_to_clust:
#							pbclust = pb_name_to_clust[pb_name]
#							print(line.split()[0] + "\t" + pbclust[0] + "\t" + pbclust[1], file=out)
#						else:
#							print(line.split()[0] + "\tNone\t1", file=out)
#					else:
#						print("sequence" + line.strip(), file=out)


#######################################################################################
##############	   	  split pb fasta file by clusters 		###############
#######################################################################################
###########	 (to be corrected: should be done per chunk now)	    ###########
#######################################################################################

# TODO: change outputDir
#rule split_fasta_file_by_cluster:
#	input: outputDir + "/{sample}_with_cluster.fasta"
#	output: temp(expand(outputDir + "/splitted-per-cluster/{{sample}}_cluster{clust}_temp.fasta", clust=clusters)),
#	log: "log/split_fasta_file_by_cluster_{sample}.log"
#	shell: 
#		'''
#		(time set +o pipefail && 
#		awk 'BEGIN{{RS=\">\"}} NR>1 {{gsub(\"\\n\", \"\\t\"); print \">\"$0}}' {input} | 	# put every read(name + sequence) in one single line
#		awk '$2!=\"None\" {{print>\"{outputDir}/splitted-per-cluster/{wildcards.sample}_cluster\"$2\"_temp.fasta\"}}' && 
#		touch {output}) > {log} 2>&1
#		'''

# This rule converts the temporary files (which have each read (name+seq) in one line) to the right fasta format files
#rule correct_fasta_files:
#	input: outputDir + "/splitted-per-cluster/{sample}_cluster{clust}_temp.fasta"
#	output: outputDir + "/splitted-per-cluster/{sample}_cluster{clust}.fasta"
#	log: "log/correct_fasta_files_{sample}_{clust}.log"
#	shell: "(time awk \'{{gsub(\"\\tsequence\", \"\\n\")}}; {{print $0}}\' {input} > {output}) > {log} 2>&1"


# FIXME: clustpair shouldn't be used here
#rule merge_and_correct_dir_paired_clust_fasta:
#	input:
#		lambda wc: expand(outputDir + "/splitted-per-cluster/" + wc.sample + "_cluster{pair}.fasta", pair = [wc.clust, clustpair[wc.clust]]),
#	output:
#		outputDir+"/splitted-per-cluster/{sample}_cluster{clust}_with_RCpair.fasta"
#	run:
#		os.system("cat " + input[0] + " > " + output[0])
#		revcompfasta(input[1], output[0])




###################################################################
##########		clustering SS reads		###########
###################################################################

#TODO: add lib names to the ss names: ssname_lib_flag_chrom_pos
#rule count_SS_clust_cov:
#	input: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_withclust.maf"
#	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_SS_cov.data"
#	log: "log/count_SS_clust_cov_{sample}_chunk{chunks}_k{kMinimap}_w{w}_f{f}_z{z}.log"
#	shell:
#		'''
#		(time awk '{{print $2\"_\"$3\"_\"$4\"_\"$5\"_\"$6\"_len:\"$7, $10, $20}}' {input} | tail -n +2 | sort | uniq -c > {output}) > {log} 2>&1
#		'''

#rule count_SS_clust_cov:
#	input: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_withclust.maf.gz"
#	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_SS_cov.data"
#	log: "log/count_SS_clust_cov_{sample}_chunk{chunks}_k{kMinimap}_w{w}_f{f}_z{z}.log"
#	shell:
#		'''
#		(time zcat {input} | awk '{{print $2, $3, $4, $5, $6, $7, $10, $20}}' | tail -n +2 | sort | uniq -c > {output}) > {log} 2>&1
#		'''


#rule cluster_SS_reads:
#	input:
#		ss_clust_count=expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/{{sample}}_chunk{chunks}_SS_cov.data", chunks=chunkID),
#		clust_partners="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/clust_partners.txt"
#	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/SS_clusters.data"
#	log: "log/cluster_SS_reads_k{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
#	script: "utils/cluster_SS_reads2.snakemake.R"

rule count_SS_clust_cov:
	input:
		minimap="aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}.maf.gz",
		soft_clust="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/{sample}_chunk{chunks}_clusters.RData",
		clust_partners="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/clust_partners.txt"
	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_SS_cov.data"
	log: "log/count_SS_clust_cov_{sample}_chunk{chunks}_k{kMinimap}_w{w}_f{f}_z{z}.log"
	script: 'utils/countSSclustCov.R'

## TODO: it takes so long. Optimize the runtime by using only one cluster...
#rule cluster_SS_reads:
#	input:
#		minimap=expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/{{sample}}_chunk{chunks}.maf.gz", chunks=chunkID),
#		soft_clust="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/soft_clusters_long_reads.data",
#		clust_partners="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/clust_partners.txt"
#	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/SS_clusters.data"
#	log: "log/cluster_SS_reads_k{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
#	script: "utils/cluster_ss_reads.snakemake.py"

rule cluster_SS_reads:
	input:
		ss_clust_cov=expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/{{sample}}_chunk{chunks}_SS_cov.data", chunks=chunkID),
	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/SS_clusters.data"
	log: "log/cluster_SS_reads_k{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
	script: "utils/cluster_ss_reads2.snakemake.py"



# TODO: correct later: ss names in the input fasta file shouldn't have lib name
#rule append_clusters_to_SS_read_names:
#	input:
#		clustering="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/SS_clusters.data",
#		ss_reads=SSfastqDir+"/merged/{x}.combined.withmapinfo.fasta"
#	output: SSfastqDir+"/merged/{x}.combined.withmapinfo_k{kMinimap}_w{w}_f{f}_z{z}_{sample}.fasta"
#	log: "log/append_clusters_to_SS_read_names_k{kMinimap}_w{w}_f{f}_z{z}_{sample}_{x}.log"
#	run:
#		# mapping PacBio readNames to their clusters and soft probs
#		name_to_clust_len={}
#		with open(input["clustering"]) as clust:
#			for line in clust:
#				sp = line.strip().split()
#				if sp[0] != "clust.forward":
#					ss_parts=sp[1].split("_len:")
#					name_to_clust_len[ss_parts[0]]=(sp[0], ss_parts[1])
#		
#		# writing PacBio reads clusters in the PacBio fasta file
#		with open(input["ss_reads"]) as f:
#			with open(output[0], 'w') as out:
#				for line in f:
#					if line[0]==">":
#						name=line.strip()[1:]
#						if name in name_to_clust_len:
#							print(">" + name + "_clust:" + name_to_clust_len[name][0] + "_len:" + name_to_clust_len[name][1], file=out)
#						else:
#							print(">" + name + "_clust:None", file=out)
#					else:
#						print(line.strip(), file=out)
#

###########################################################################
##########		mapping SS reads to bubbles		###########
###########################################################################
# mummer [options] ref query
# -c can be used to make the reverse complemented query positions be reported relative to the original strand (not the reverse strand)
rule map_SS_reads_to_snv_bubbles:
	input:
		SSreads=SSfastqDir+"/merged/{x}.combined.withmapinfo.fasta", #SSfastqDir+"/merged/{x}.combined.withmapinfo_k{kMinimap}_w{w}_f{f}_z{z}_{sample}.fasta",
		bubble="bubbles/snv_bubbles_k{k}_a{a}_l{l}_withlen_and_refmap_info.fa"
	output: SSfastqDir + "/exact_map_{x}_snv_bubbles_k{k}_a{a}_l{l}.data"
	log: "log/map_SS_reads_to_snv_bubbles_{x}_k{k}_a{a}_l{l}.log"
	shell: "(time mummer -l {wildcards.k} -b {input.bubble} {input.SSreads} > {output}) > {log} 2>&1"


# TODO: change to output also the mapping positions (not only the names)
rule output_valid_maps:
	input:
		map=SSfastqDir + "/exact_map_{x}_snv_bubbles_k{k}_a{a}_l{l}.data",
		ss_reads=SSfastqDir+"/merged/{x}.combined.withmapinfo.fasta",
		clustering="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/SS_clusters.data",
	output: SSfastqDir + "/valid_exact_map_{x}_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data"
	log: "log/output_valid_maps_and_SS_bubble_cov_{x}_snv_bubbles_k{k}_a{a}_l{l}.log"
	script: "utils/output_valid_maps.py"


###################################################################
##########		clustering bubbles		###########
###################################################################

rule count_bubble_clust_coverage:
	input: SSfastqDir + "/valid_exact_map_{x}_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data"
	output: SSfastqDir + "/bubble_clust_cov_{x}_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data"
	log: "log/count_bubble_clust_coverage_{x}_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
	shell: "(time tail -n +2 {input} | awk '{{print $3, $4, $5, $6, $7, $8}}' | sort | uniq -c > {output}) > {log} 2>&1"


rule cluster_snv_bubbles:
	input:
		bubble_clust_count=expand(SSfastqDir + "/bubble_clust_cov_{x}_snv_bubbles_k{{k}}_a{{a}}_l{{l}}_kminimap{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_{{sample}}.data", x=libs),
		clust_to_chrom="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/clust_partners.txt",
	output:
		bubbles_clust="bubbles/snv_bubbles_clusters_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data",
	log: "log/cluster_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
	script: "utils/cluster_snv_bubbles2.snakemake.R"


#rule add_bubble_clust_to_maps:
#	input:
#		bubbles_clust="tmp/snv_bubbles_clusters_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data",
#		map=SSfastqDir + "/valid_exact_map_{x}_snv_bubbles_k{k}_a{a}_l{l}.data",
#		clust_to_chrom="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/clust_partners.txt",
#	output: SSfastqDir + "/valid_exact_map_with_bubble_clust_{x}_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data"
#	log: "log/add_bubble_clust_to_maps_{x}_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
#		script: "utils/add_bubble_clust_to_maps.snakemake.R"



rule append_clusters_to_bubble_names:
	input:
		bubbles_clust="bubbles/snv_bubbles_clusters_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data",
		bubbles="bubbles/snv_bubbles_k{k}_a{a}_l{l}_withlen_and_refmap_info.fa"
	output: "bubbles/snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}_withclsut.fa"
	run:
		# mapping bubble names to their clusters
		bubble_id_to_clust={}
		with open(input["bubbles_clust"]) as clustbubble:
			for line in clustbubble:
				sp = line.strip().split()
				if sp[0] != "clust.forward": # skip the header line
					bubble_id_to_clust[sp[1]]=sp[0]
		
		# writing bubbles clusters in bubbles fasta file
		with open(input["bubbles"]) as f:
			with open(output[0], 'w') as out:
				for line in f:
					if line[0]==">":
						name=line.strip()[1:]
						bubble_id = name.split("_")[1]
						if bubble_id in bubble_id_to_clust:
							clust = bubble_id_to_clust[bubble_id]
							print(line.strip() + "\t" + clust, file=out)
						else:
							print(line.split()[0] + "\tNone", file=out)
					else:
						print(line.strip(), file=out)


###################################################################################
##########		realignment of SS reads to PB reads		###########
###################################################################################

rule output_bubble_SSlib_coverage_matrix:
	input:
		wc_cell_clust="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/wc_cells_clusters.data",
		bubbles_clust="bubbles/snv_bubbles_clusters_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data",
		valid_maps=expand(SSfastqDir + "/valid_exact_map_{x}_snv_bubbles_k{{k}}_a{{a}}_l{{l}}_kminimap{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_{{sample}}.data", x=libs),
		clust_to_chrom="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/clust_partners.txt",
	output: expand(SSfastqDir + "/bubble_SSlib_cov_cluster{clust}_snv_bubbles_k{{k}}_a{{a}}_l{{l}}_kminimap{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_{{sample}}.data", clust=clusters)
	log: "log/output_bubble_ss_lib_coverage_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
	script: "utils/output_bubble_ss_lib_coverage.snakemake.R"


# TODO: fix the problem of strandphaser phased bubbles. Haplotype sorting of strand states is accurate, but phasing bubbles is not accurate.
rule strandphaser:
	input:
		wc_cell_clust="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/wc_cells_clusters.data",
		bubble_lib_cov_matrix=expand(SSfastqDir + "/bubble_SSlib_cov_cluster{clust}_snv_bubbles_k{{k}}_a{{a}}_l{{l}}_kminimap{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_{{sample}}.data", clust=clusters),
		clust_to_chrom="aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/clust_partners.txt",
	output:
		phased_strand_states="phased_strand_states/haplo_strand_states_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data",
		phased_bubbles="bubbles/strandphaser_phased_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data"
	log: "log/strandphaser_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
	script: "utils/strandphaser.snakemake.R"


rule phase_snv_bubbles_from_strand_phaser:
	input:
		SS_bubble_map=expand(SSfastqDir+"/valid_exact_map_{x}_snv_bubbles_k{{k}}_a{{a}}_l{{l}}_kminimap{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_{{sample}}.data", x=libs),
		phased_strand_states="phased_strand_states/haplo_strand_states_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data",
	output: "bubbles/iteration1_phased_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}_withclsut.data"
	script: "utils/phase_snv_bubbles_from_strandphaser.snakemake.py"


#rule phase_snv_bubbles:
#	input:
#		SS_bubble_map=expand(SSfastqDir+"/valid_exact_map_{x}_snv_bubbles_k{{k}}_a{{a}}_l{{l}}_kminimap{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_{{sample}}.data", x=libs),
#		SS_haplo_strand_states=expand("ground_truth_strand_states/{lib}_haplo_strand_states_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_{{sample}}.data", lib=libs), # TODO: to be replaced by strandphaser output
#	output: "bubbles/iteration1_phased_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}_withclsut.data"
#	script: "utils/phase_snv_bubbles.snakemake.py"


rule minimap_align_bubbles_to_PB_reads:
	input:
		bubbles="bubbles/snv_bubbles_k{k}_a{a}_l{l}.fa",  #"bubbles/snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}_withclsut.fa",
		pb_reads=PBbamDir+"/{sample}.{chunks}.fasta"
	output:
		"aligns_k{kMinimap}_w{w}_f{f}_z{z}/snv_bubbles_k{k}_a{a}_l{l}_{sample}_{chunks}.paf.gz"
	threads: 8
	log: "log/minimap_align_bubbles_to_PB_reads_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}_{chunks}.log"
	shell: "(time minimap2 -c -t{threads} -k{wildcards.kMinimap} -w{wildcards.w} -f{wildcards.f} -z{wildcards.z} {input.pb_reads} {input.bubbles} | gzip -c > {output}) > {log} 2>&1"


rule export_bubble_pb_het_kmers:
	input:
		bubbles="bubbles/snv_bubbles_k{k}_a{a}_l{l}.fa",  #"bubbles/snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}_withclsut.fa",
		bubbles_clust_file="bubbles/snv_bubbles_clusters_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.data",
		bubble_PB_minimap="aligns_k{kMinimap}_w{w}_f{f}_z{z}/snv_bubbles_k{k}_a{a}_l{l}_{sample}_{chunks}.paf.gz",
		#SS_haplo_strand_states=expand("ground_truth_strand_states/{lib}_haplo_strand_states_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_{{sample}}.data", lib=libs), # TODO: to be replaced by strandphaser output
		#bubble_phase_file="bubbles/iteration1_phased_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}_withclsut.data",
		PB_fasta=PBbamDir+"/{sample}.{chunks}.fasta"
	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/het_kmers/bubble_pb_het_kmers_chunk{chunks}_k{k}_a{a}_l{l}_{sample}.data"
	params:
		het_kmer_len=config["het_kmer_len"]
	log: "log/export_bubble_pb_het_kmers_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
	script: "utils/export_bubble_PB_het_kmers.snakemake.py"


rule phase_long_reads:
	input:
		het_kmers_edit_dist="aligns_k{kMinimap}_w{w}_f{f}_z{z}/het_kmers/bubble_pb_het_kmers_chunk{chunks}_k{k}_a{a}_l{l}_{sample}.data",
		bubble_phase_file="bubbles/iteration1_phased_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}_withclsut.data",
	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/phased_long_reads/iteration1_pb_phase_chunk{chunks}_k{k}_a{a}_l{l}_{sample}.data"
	script: "utils/phase_long_reads.snakemake.py"


rule update_bubbles_phasing:
	input:
		het_kmers_edit_dist=expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/het_kmers/bubble_pb_het_kmers_chunk{chunks}_k{{k}}_a{{a}}_l{{l}}_{{sample}}.data", chunks=chunkID),
		long_reads_phase_file=expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/phased_long_reads/iteration1_pb_phase_chunk{chunks}_k{{k}}_a{{a}}_l{{l}}_{{sample}}.data", chunks=chunkID)
	output: "bubbles/iteration2_phased_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}_withclsut.data"
	script: "utils/update_bubbles_phasing.snakemake.py"

rule update_long_reads_phasing:
	input:
		het_kmers_edit_dist="aligns_k{kMinimap}_w{w}_f{f}_z{z}/het_kmers/bubble_pb_het_kmers_chunk{chunks}_k{k}_a{a}_l{l}_{sample}.data",
		bubble_phase_file="bubbles/iteration2_phased_snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}_withclsut.data",
	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/phased_long_reads/iteration2_pb_phase_chunk{chunks}_k{k}_a{a}_l{l}_{sample}.data"
	script: "utils/phase_long_reads.snakemake.py"


#rule merge_phased_long_reads:
#	input: expand(temp("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/phased_long_reads/pb_phase_chunk{chunks}_k{{k}}_a{{a}}_l{{l}}_{{sample}}.data"), chunks=chunkID)
#	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/phased_long_reads/pb_phase_k{k}_a{a}_l{l}_{sample}.data"
#	shell: 
#		'''
#		cat <(head -n 1 {input[0]}) <(ls {input} | xargs --max-args 1 tail -n +2) > {output}
#		'''
#	


#rule export_het_kmers:
#	input:
#		bubbles="bubbles/snv_bubbles_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}_withclsut.fa",
#		#SS_bubble_map=expand(SSfastqDir+"/valid_exact_map_with_bubble_clust_{x}_snv_bubbles_k{{k}}_a{{a}}_l{{l}}_kminimap{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_{{sample}}.data", x=libs),
#		SS_bubble_map=expand(SSfastqDir+"/valid_exact_map_{x}_snv_bubbles_k{{k}}_a{{a}}_l{{l}}_kminimap{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_{{sample}}.data", x=libs),
#		SS_PB_minimap="aligns_k{kMinimap}_w{w}_f{f}_z{z}/{sample}_chunk{chunks}_withclust.maf.gz",
#		SS_haplo_strand_states=expand("ground_truth_strand_states/{lib}_haplo_strand_states_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_{{sample}}.data", lib=libs), # TODO: to be replaced by strandphaser output
#		PB_fasta=PBbamDir+"/{sample}.{chunks}.fasta"
#	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/PacBio_het_kmers_chunk{chunks}_k{k}_a{a}_l{l}_{sample}.data"
#	params:
#		het_kmer_len=config["het_kmer_len"]
#	script: "utils/export_PB_het_kmers.snakemake.py"


#rule compute_haplo_edit_distance:
#	input: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/PacBio_het_kmers_chunk{chunks}_k{k}_a{a}_l{l}_{sample}.data"
#	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/PacBio_haplo_edit_dist_chunk{chunks}_k{k}_a{a}_l{l}_{sample}.data"
#	log: "log/compute_haplo_edit_distance_chunk{chunks}_k{k}_a{a}_l{l}_kminimap{kMinimap}_w{w}_f{f}_z{z}_{sample}.log"
#	script: "utils/compute_haplo_edit_distance.py"



######################################
#finding heterozygous unitigs
######################################

## computing the ground truth het unitifs:
## mapping unitigs to the reference genome

rule bwa_index_ref:
	input: config["reference"]
	output:
		config["reference"] + ".amb",
		config["reference"] + ".ann",
		config["reference"] + ".bwt",
		config["reference"] + ".pac",
		config["reference"] + ".sa"
	log: "log/bwa_index_ref.log"
	shell: "(time bwa index {input}) > {log} 2>&1"

rule samtools_index_ref:
	input: config["reference"]
	output: config["reference"] + ".fai"
	log: "log/samtools_index_ref.log"
	shell: "(time samtools faidx {input}) > {log} 2>&1"

### TODO: output unitigs from the gfa file


## bubble detection
rule bubble_detection:
	input: GRAPHPATH + "graph_k{k}_a{a}_l{l}.gfa"
	output: "bubbles/bubbles_k{k}_a{a}_l{l}.fa"
	log: "log/bubble_detection_k{k}_a{a}_l{l}.log"
	shell: "(time python utils/simple_bubbles.py {input} > {output}) > {log} 2>&1"

# Note: for each bubble, exactly two alleles should be written in the output file
rule output_snv_bubbles:
	input: "bubbles/bubbles_k{k}_a{a}_l{l}.fa"
	output: "bubbles/snv_bubbles_k{k}_a{a}_l{l}.fa"
	log: "log/output_snv_bubbles_k{k}_a{a}_l{l}.log"
	script: "utils/get_snv_bubbles.py"


##########################################################################################################

# TODO: remove later. It is added to the evaluation pipeline
rule bwa_map_snv_bubble_unitigs_to_ref:
	input:
		ref=config["reference"],
		amb=config["reference"] + ".amb",
		ann=config["reference"] + ".ann",
		bwt=config["reference"] + ".bwt",
		pac=config["reference"] + ".pac",
		sa=config["reference"] + ".sa",
		unitigs="bubbles/snv_bubbles_k{k}_a{a}_l{l}.fa"
	output: "bubbles/mapped_contigs_k{k}_a{a}_l{l}.snv.bubbles.unitigs.sorted.bam"
	log: "log/bwa_map_snv_bubble_unitigs_to_ref_k{k}_a{a}_l{l}.log"
	shell:
		"(time bwa mem -t 46 -c 1 {input.ref} {input.unitigs} | samtools view -Sb - > {output}) > {log} 2>&1"

rule output_bubbles_withlen_and_refmap_info:
	input: "bubbles/mapped_contigs_k{k}_a{a}_l{l}.snv.bubbles.unitigs.sorted.bam"
	output: "bubbles/snv_bubbles_k{k}_a{a}_l{l}_withlen_and_refmap_info.fa"
	log: "log/output_bubbles_withlen_and_refmap_info_k{k}_a{a}_l{l}.log"
	shell:
		'''
		(time bioawk -c sam '{{s=$seq; if(and($flag, 16)) {{s=revcomp($seq)}} print \">\" $qname \"_\" $flag \"_\" $rname \"_\" $pos \"_len:\" length($seq) \"\\n\" s}}' \
		<(samtools view -F 4 {input}) > {output}) > {log} 2>&1
		'''

# TODO: remove later. It is added to the evaluation pipeline
#rule sort_bam_snv_bubbles:
#	input: "bubbles/mapped_contigs_k{k}_a{a}_l{l}.snv.bubbles.unitigs.sorted.bam"#	output: "bubbles/mapped_contigs_k{k}_a{a}_l{l}.snv.bubbles.unitigs.sorted.bam"
#	log: "log/sort_bam_snv_bubbles_k{k}_a{a}l{l}.log"
#	shell: "(time samtools sort -o {output} {input}) > {log} 2>&1"


rule export_snv_bubble_unitigs_fasta_from_bam:
	input: "bubbles/mapped_contigs_k{k}_a{a}_l{l}.snv.bubbles.unitigs.sorted.bam"
	output: "bubbles/snv_bubbles_k{k}_a{a}_l{l}_with_refmap_info.fa"
	log: "log/export_snv_bubble_unitigs_fasta_from_bam_k{k}_a{a}_l{l}.log"
	shell: "(time perl utils/printRead2fasta_pacbio.pl {input} > {output}) > {log} 2>&1"




